# INFO.md
This file contains a collection of arguments and information researched individually by members of our group. It has been compiled to ensure that all team members are up to speed with the project's components. In case of any doubts or need for clarification, this document serves as a reference point to look up the relevant information.

# TOC
- [UART](#uart)
  - [Pin Functions](#pin-functions)
  - [Connections](#connections)
  - [Firmware](#firmware)
- [Rotary Encoder](#rotary-encoder)
  - [Pin Functions](#pin-functions-1)
- [OLED Display](#oled-display)
  - [Pin Functions](#pin-functions-2)
- [Keyboard Matrix](#keyboard-matrix)
  - [Set Up](#set-up)
  - [How it works](#how-it-works)
- [Power](#power)
- [Mechanical Debouncing](#mechanical-debouncing)
- [Software Debouncing](#software-debouncing)
- [Interrupt](#interrupt)
- [Messages](#messages)
- [Driver](#driver)
  - [How it works](#how-it-works-1)
  - [Permissions](#permissions)

# UART
**UART** (**Universal Asynchronous Receiver-Transmitter**) is a hardware communication protocol that enables asynchronous serial communication between devices. It transmits data one bit at a time without requiring a shared clock signal. Instead, it uses start and stop bits to frame the data, along with optional parity for error detection.

<img src="assets/uart.jpg" alt="UART" style="height: auto; max-width: 800px">

## Pin Functions
1. `GND`: Is the **Ground**, this is the common ground reference for all the signals. It must be connected between the computer and the MCU.

2. `CTS`: Is the **Clear to Send**, this is a flow control pin (**WE DON'T USE IT**). When using hardware flow control, the **receiver** pulls this pin **LOW (0V)** to signal that it is ready to receive data.

3. `VCC`: Is the **Power Delivery**, this pin provides power from the computer to the MCU. The voltage level depends on the cable, in our case is 5V.

4. `TXD`: Is the **Transmit Data**, this is the data output from the computer to the MCU. The computer sends data on this pin, and the MCU receives it on its **RXD** pin.

5. `RXD`: Is the **Receive Data**, this is the data input to the computer from the MCU. The MCU sends data on this pin, and the computer receives it on its **TXD** pin.

6. `RTS`: Is the **Request to Send**, this is a flow control pin (**WE DON'T USE IT**). The transmitter pulls this pin **LOW (0V)** to request permission to send data.

## Connections
- `GND` ↔ `GND`  
- `TXD` ↔ `RXD`  
- `RXD` ↔ `TXD`  
- `VCC` ↔ `3V3`

## Firmware
In the firmware when a key press is detected the corresponding signal is sent via the UART

# Rotary Encoder
A rotary encoder is a sensor that detects rotation and converts it into an electrical signal. The rotary encoder i have selected also acts like a switch so other than be rotated it can also be pressed

<img src="assets/rotary-encoder.jpg" alt="Rotary Encoder"  style="max-height: 500px; width: auto;">

## Pin Functions
1. `Channel A`: Outputs a pulse signal when the encoder is rotated.
2. `Channel B`: Outputs a pulse signal slightly out of phase with Channel A (if i read the data-sheet correctly it is 90° out of phase with **channel A**)
3. `Common`: GND
4. `SW_1_PIN`: Normal switch header
5. `SW_2_PIN`: Normal switch header

# OLED Display
The OLED Display uses I2C

<img src="assets/oled.jpg" alt="OLED Display" style="height: auto; max-width: 500px">

## Pin Functions
1. `GND`: Ground  
2. `VIN`: Is the power delivery to make the display work
3. `SCL`: Is the **Serial Clock Line** and it carries the clock signal generated by the I2C master. This lets us synchronizes communication between the master and the rotary encoder.
4. `SDA`: Is the **Serial Data Line** and it carries the actual data between the master and the encoder.

# Keyboard Matrix 
A keyboard matrix is a method used to connect multiple switches to a MCU while minimizing the number of GPIO pins required. Instead of connecting each key to a separate pin, the keys are arranged in a grid-like pattern, reducing the number of connections needed.

MCU, including the MSP432, have a limited number of GPIO pins. If each key were connected to its own pin, we would quickly run out of available pins, especially for large keyboards. By organizing the keys into a matrix configuration, we can efficiently read the state of many switches using fewer pins.

<img src="assets/switch-matrix.png" alt="Switch Matrix"> 

## Set Up
For this particular setup, we use a **6-row by 17-column matrix**, allowing us to control and read up to **102 keys** while only using **23 GPIO pins** instead of 102.    

- **Rows (6 total) → Configured as Outputs**
  These pins are set as outputs, driving signals into the matrix to scan for key presses.

- **Columns (17 total) → Configured as Inputs**
  These pins are set as inputs with internal pull-Up resistors to detect changes when a key is pressed.

## How it works
This keyboard can be seen an hybrid-keyboard because it uses both  interrupt and polling to detect a key press:

1. The MCU activates sets all row to high
2. If a interrupt is triggered on one of the columns it means a key has been pressed
3. The MCU sets one row at the time (polling) to high and once it finds an high value on the right column (the column is known thanks to the flag of the interrupt) it has the coordinates of the key that triggered the interrupt
4. Send the coordinates and info to the driver that, based on the OS, emulates the right keypress

# Power
The cable other than UART communication does also **Power Delivery**, not at 3V3 but at 5V so we use a **voltage regulator** that brings down the voltage to 3V3.

# Mechanical Debouncing
Because the electrical components may accidentally make multiple distinct contacts on a single switch press we have a minimal debouncing implementation in the firmware. For each key we have a key state, in which we store a timestamp (possibly 0) indicating the last time it was pressed.

On each key press event we receive (from the interrupts and keyboard matrix logic described above) we get the timestamp of the last press. If 0 then we send the event via uart, otherwise we calculate the difference between the current timestamp and the last one. If it's below a certain threshold (20ms) then the event is valid and we update the timestamp to the current one, otherwise we ignore it.

# Software Debouncing

# Interrupt

# Messages
To comunicate via UART the keycard and the computer uses a messaging "protocol" that we hat to implement due to the limited size of the data sended thought the UART (on the MSP432 the maximum size of a UART message is 8bit = 1byte).

The keyboard sends **1 message** composed of **3 fragments** that are composed of **2 packets** each, so 6 packets total. The message is the following struct:
```c
typedef struct {
    Fragment x;
    Fragment y;
    Fragment info;
} Message;
```

The fragment is another struct:
```c
typedef struct {
    FrgType fragment_type;
    uint8_t data;
} Fragment;
```

Because the UART can send only 8 bit we decided to make the data field of the fragment a `uint8_t` to prevent any error in size and loss of data. The same is for the `FrgType` (= Fragment Type) which is the following enum:
```c
typedef enum : uint8_t {
    X,
    Y,
    INFO,
} FrgType;
```

This packets are sent in order (X_TYPE, X_DATA, Y_TYPE, Y_DATA, INFO_TYPE, INFO_DATA) one after the other and on the driver side it is checked the order and reassembled.


# Driver
## How it works
## Permissions
- Windows: may need Administrator permissions (to test)
- Linux: needs access to dev/uinput (typically root)
- macOS: needs accessibility permissions